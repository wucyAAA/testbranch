-------------------------------------helloworld--------------------------------------
模板页面：html+js
js以什么形式(语法)存在
  	指令：vue自定义标签属性 例子:v-model
	插值：动态显示数据，例子: {{msg}}
	指令和插值中的表达式自动从data中动态获取数据
-------------------------------------模块化语法--------------------------------------
1.双大括号表达式(插值) {{content}} （写在data对象里）
2.指令一：强制数据绑定  例子: v-bind ：+标签   简写：冒号+标签（写在data对象里）
3.指令二：绑定事件监听 例子: v-on:click='test1' 简写: @click='test1'（写在methods对象里）
-------------------------------------Object.defineProperty--------------------------------------
Object.defineProperty(obj,prop,descriptor)
直接在一个对象上定义一个新属性，或修改属性，返回这个对象。
descriptor参数为一个对象，对象有set和get方法(也有其他的方法),
get()当读取属性值时自动调用，函数的返回值作为属性值，this是函数所属的对象。
set(value)当修改属性值时自动调用，用来监视属性值的变化，this是函数所属的对象。
---------------------------------------弄清回调函数的3个问题-----------------------------------
1.啥时候调用？2.它的作用是什么？3.函数的this是谁？思考要有层次感！！！！！
---------------------------------------计算属性computed-----------------------------------
计算属性:通过计算动态产生一个要显示的结果数据
方法：包装getter , 执行时机：初始显示第一次执行,得到初始值显示,依赖数据发生改变会再次调用
1.只用getter,计算属性是一个函数
2.使用getter/setter，计算属性是一个包含getter和setter的对象
get()//计算产生要显示的值
set()//监视值的变化
===========================================================
#所有vue控制的回调函数的this都是vm或者组件对象。
#打印一个实例对象，控制台显示的是它的类型名称！！！！
===========================================================
---------------------------------------监视属性watch-------------------------------------------
监视vm那个属性的变化
---------------------------------------计算属性有缓存-------------------------------------------
计算属性存在缓存，多次读取只执行一次getter计算，是通过对象来缓存数据的。
---------------------------------------强制绑定class和style---------------------------------------
动态的class什么时候用字符串语法：类名是不确定的
动态class什么时候用对象语法：类名确定，但不确定到底有没有（true或false来指定有没有该类）
------------------------------------------条件渲染-------------------------------------------------
                                                 v-if/v-else  v-show
---------------------------------------列表渲染---------------------------------------------------
语法： v-for='(p,index) in persons'
vue的数据绑定如何实现的
1.vue 会监视data中所有层次的属性
2.对象中的属性数据通过添加set方法来实现监控
3.数组的元素也实现了监视：重写数组一系列更新元素的方法
      1).调用原生对应的方法对元素进行处理   2).去更新界面
---------------------------------------列表搜索的过滤和排序--------------------------------------------------
@click=''及可以指定回调函数，也可直接设置data里的属性值
例如：<button @click='sortType=2'>点击</button> filter() indexOf() sort()
---------------------------------------复习！！---------------------------------------------------
vm.$mount()指定dom标签容器的选择器，vue就会管理对应的标签及其子标签。
模板页面数据的来源有两个一个是data另一个是computed  {{m}}
v-model :双向数据绑定，自动收集用户输入数据 ~~~~模型data <--->视图页面
模型data --->视图页面 就是单向数据绑定（所有的指令都有）
---------------------------------------通过v-model收取表单数据（痛苦）---------------------------------------------------

---------------------------------------利用生命周期实现功能--------------------------------------
生命周期钩子：
  	beforecreate created                     beforemount mounted 
	beforeupdate updated(指的是更新页面，不是指数据) beforedestroy destroyed

---------------------------------------自定义过滤器filter------------------------------------
---------------------------------------自定义指令------------------------------------------------
！！！！！！！！！！！！所有的指令都是用来操作指令属性所在的标签！！！！！！！！！！！！！！！！！！！
---------------------------------------自定义插件_了解------------------------------------------------------------------------
插件可以是函数类型也可以是对象类型。
---------------------------------------自定义组件-------------------------------------------------
！！！！！！！！！！自定义组件里的data只能是函数类型。！！！！！！！！！！！！
 ！！！因为如果是对象类型的话，当使用多个组件时，一个组件的data会影响另一个组件的data！！！！！
如果是函数的话，每执行一次返回的是不同的data对象。
--------------------------------------------webpack-----------------------------------------------
打包命令：npx webpack 或者在package.json文件中配置build命令 
"scripts":{
     "build":"webpack --mode production"	--mode production可加
  }
13_开发环境运行视频!!
--------------------------------------------搭建vue开发环境--------------------------------
import App from './App.vue' //引入自定义组件
new Vue({
    components:{
        App:App     ==>>>注册组件局部注册      Vue.component('App',App)全局注册
    },                               注册后才能写组件标签
    template:'<App/>'
}).$mount('#root')
=======================================================
一个组件对象就是一个小的vm
组件内回调函数的this是组件对象
模板中获取数据读取组件对象的对应属性值
========================================================
区分使用生产环境与开发环境
 使用生产环境：npm  run build ==> webpack
  1).在内存中进行编译打包，生成内存中的打包文件
  2).保存到本地（在本地生成打包文件）==>此时还不能通过浏览器来访问，需要启动服务器运行。
使用开发环境：npm run dev ==> webpack-dev-server
1).在内存中进行编译打包，生成内存中的打包文件
 2).启动服务器，运行内存中的打包文件==>可以通过浏览器虚拟路径访问。
=========================================================
 resolve: {
            extensions: ['.js', '.vue', '.json'], // 可以省略的后缀名
            alias: { // 路径别名(简写方式)
              'vue$': 'vue/dist/vue.esm.js',  // 表示精准匹配
	'@':path.resolve(__dirname,'src') 工作中经常看到别人这么用@符号相当于src
            }
          }
--------------------------------------------vue组件化编码------------------------------------
组件化编码的基本流程：
	1.拆分界面，抽取组件。
	2.编写静态组件
	3.编写动态组件：初始化数据，动态显示初始化界面。 实现与用户交互功能。
设计data：
	类型：[{id:1,title:'',completed:false}]
	名称:todos
	位置：如果只是那个组件用，交给它，如果是那些组件用，交给共同的父组件。
状态数据的更新
	data数据定义在那个组件，更新数据的行为就定义在那个组件，
	如果子组件要更新父组件的数据，调用父组件的更新函数来更新父组件的数据，
	一个组件接收属性数据不要直接修改，只是用来读取显示的。
任何界面的变化都是数据的变化，修改数据界面就变了称为 单向绑定一般说成数据绑定。

数组的reduce方法
filter（）有时间听一下  computed watch 生命周期 cookie session localStorage
-------------------------------------------组件间通信自定义事件-------------------------------
绑定方式之一：
mounted(){
       this.$ref.header.$on('addTodo',this.addTodo)
}
 
绑定事件监听和分发事件的组件对象必须是同一个组件对象
创建一个全局的用于绑定事件监听和分发事件的对象:Global Event Bus (全局事件总线)
Vue.prototype.$globalEventBus=new Vue()
或
beforeCreate(){
  Vue.prototype.$globalEventBus=this
}
组件对象与Vue是什么关系？
	所有组件对象的原型对象都是一个vm对象
	所有组件对象都能看到定义在Vue原型对象上的属性或方法
-------------------------------------------组件间通信内置组件slot----------------------------
只听不做！嘿嘿
-------------------------------------------组件间通信使用pubsub----------------------------
还要下载包，不如用全局事件总线！
-----------------------------------------解决ajax请求跨域（没听懂日后考古day5）----------------------------
slot通信也没听明白
编译es6的高级语法要下载包还要配置 ！
----------------------------------------vue-router-------------------------------------------------------------- 
什么是路由？ 一个key与value的对应关系
	后台路由指 path与回调函数
	前台路由指 path与组件(component)
路由组件对象是在第一次请求对应路径时才创建的
从一个路由组件离开，路由组件死亡，在进入需要重新创建
当同一个路由路径上做切换(只是改了参数),当前路由组件对象被直接复用。
同一个组件对象mounted()只执行一次
设置动态路由
<router-link :to="'/home/message/messageDetails/'+msg.id">{{msg.title}}</router-link>  
<router-link :to="`/home/message/messageDetails/ + ${msg.id}`">{{msg.title}}</router-link>  
用watch监视动态路由

声明式编码: <a href=''></a>（大部分代码不用自己实现）
命令式编码:window.location=''

new Vue({
    components:{
        App:App
    },
    template:'<App/>',
    router   ------------->>>>>这一配置导致所有组件都能通过$router属性看到router对象
}).$mount('#root')                 /所有组件都有了一个代表当前路由的data数据:$route
----------------------------------------路由组件传参------------------------------------------
 {                        //动态路由
                            path:'/home/message/messageDetails/:id',
                            name:'detail',
                            component:MessageDetails,

                           // props:true,//内部自动将接收的params参数以标签属性传入路由组件
                            props:(route)=>({id:route.params.id,name:route.query.name})
   }
-------------------------------去掉路由中带的#--------------------------------------------------
hash模式:
 	路径中带#: http://localhost:8080/#/home/news
	发请求的路径: http://localhost:8080 项目根路径
	响应:返回的总是index页面 ==>path部分(/home/news)被解析为前台路由路径
						⬇⬇⬇⬇⬇⬇
	      index页面中引入的js文件将path部分(/home/news)被解析为前台路由路径   							
history模式:				                        
	路径中不带#：http://localhost:8080/home/news
	发请求的路径:http://localhost:8080/home/news
	响应:404错误
	希望:返回index页面,path部分(/home/news)被解析为前台路由路径
	解决:添加配置          
/代表当前路径的根路径   ./代表当前路径   没写相当于./

-----------------------------缓存路由组件--------------------------------------------------
语法： <keep-alive> <router-view> </router-view> </keep-alive>

-----------------------------------------vuex----------------------------------------
Vue.use(Vuex)   vuex要声明使用，不要加引号！！！！！！！！！！！！！！！！！
mutations -->一个包含n个用于直接更新状态数据的方法的对象
actions -->一个包含n个用于直接更新状态数据的方法的对象,可以包含异步操作和逻辑处理代码。
state -->相当于data对象包含n个可变的属性数据
getters -->包含n个基于state数据的getter计算属性的方法的对象

store对象         个人暂时通俗理解store是用来传数据的 this.$store   store也要 ' 注册 '
1.state:包含所有state数据的对象
2.getters:包含所有getter计算属性的对象
3.dispatch(actionName,data)
4.commit(mutationName,data)      ...运算符

import {mapState,mapGetters,mapMutations,mapActions} from 'vuex'
用 ...mapState([''     ，‘’])等来简化代码 如果方法名和要触发的方法名不一样可以写成对象的形式
！！！！！！！！！！！！！！！！！
...mapMutations(['add]) 相当于产生了{  add(){this.$store.commit('add')  }        }
------------------------------------------复习模块化编码------------------------------------------
CommonJS（支持双端模块化）
暴露语法：module.exports=value exports.xxx=value
引入语法：require()                 如何使用一个模块取决于:模块暴露的是什么

es6
暴露语法：分别暴露：export  统一暴露：export{}    默认暴露：export defalut {}/export defalut 2
                                          ⬇⬇⬇⬇⬇⬇                                          ⬇⬇⬇⬇⬇⬇
     引入语法：import {xxx,yyy} from './module1'            import module3 from './module3'
在es6的模块化规范中，用哪一种方式引入取决于用何种方式暴露。
默认暴露只能暴露一次 
（写这种语法都需要下载翻译官（Babel，browserify）翻译代码浏览器才认识）webpack强！

从后台获取的数据基本都会交给vuex管理
----------------------------------------------准备-----------------------------------------------
使伪数组能够调用数组的方法

es6语法：const lis2 = Array.from(lis)
es5语法：const lis3 = Array.prototype.slice.call(lis)
call方法是干啥的？我估计大家一上来就说改变this指向的。
                            上流回答：是用来调用函数的只是函数的this被指定为第一个参数的值。
Object.keys(obj):得到对象自身可枚举属性组成的数组
obj.hasOwnProperty(prop):判断prop是否是obj自身的属性
！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
 DocumentFragment: 文档碎片(高效批量更新多个节点)
！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
var div = document.getElementById('demo')
var fragment = document.createDocumentFragment()
var child
while (child = div.firstChild) {
  fragment.appendChild(child)
}
var lis5 =fragment.children[0].children
Array.prototype.slice.call(lis5).forEach(li=>{
  li.innerHtml='wucy'
})
div.appendChild(fragment)
！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！

---------------------------------------------数据代理---------------------
1. vue数据代理: data对象的所有属性的操作(读/写)由vm对象来代理操作
2. 好处: 通过vm对象就可以方便的操作data中的数据
3. 实现:
  1). 通过Object.defineProperty(vm, key, {})给vm添加与data对象的属性对应的属性
  2). 所有添加的属性都包含get/set方法
  3). 在get/set方法中去操作data中对应的属性
{{}} 叫插值语法




